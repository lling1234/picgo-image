# 集合	174io

## 1.Collection

### 1.2集合类体系结构

Collection单列:List可重复,set不可重复

List:ArrayList 	LinkedList

set:HashSet	TreeSet

Map双列:HashMap

### 1.3 Collection集合概述和使用

```Java
package com.ling;

import java.util.ArrayList;
import java.util.Collection;

public class CollectoinDemo01 {

    public static void main(String[] args) {
        //创建Collection集合的对象
        Collection<String> c = new ArrayList<String>();

        //添加元素
        c.add("ling");
        c.add("beijing");
        c.add("ShangHai");

        System.out.println(c);
    }
}


```

运行结果	[ling, beijing, ShangHai] Collection格式化字符串输出

### 1.4 Collection集合常用方法

#### add,remove,clear,contain,.isEmpty,size

```Java
package com.ling;

import java.util.ArrayList;
import java.util.Collection;

public class CollectoinDemo02 {

    public static void main(String[] args) {
        //创建Collection集合的对象
        Collection<String> c = new ArrayList<String>();

        //添加元素
        c.add("ling");
        c.add("beijing");
        c.add("ShangHai");
//        从集合中移除指定的元素
//        c.remove("beijing");

//        清空集合中的元素
//        c.clear();

        //判断集合中是否存在指定的元素,返回true和false
//        System.out.println(c.contains("ling"));

        //判断集合是否为空,返回true和false
//        System.out.println(c.isEmpty());

        //集合的长度,可就是集合中元素的个数
//        System.out.println(c.size());

        System.out.println(c);
    }
}

```

### 1.5 Collection集合的遍历

### Iterator:迭代器,集合的专用遍历方式

```java
package com.ling.Iterator02;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorDemo {

    public static void main(String[] args) {
        //创建集合对象
        Collection<String> c = new ArrayList<>();

        //添加元素
        c.add("hello1");
        c.add("hello2");
        c.add("hello3");

        //返回此集合中元素的迭代器,通过集合的Iterator()方法得到
        Iterator<String> it = c.iterator();

        /*
        public Iterator<E> iterator() {
            return new Itr();
        }
         */

//        System.out.println(it.next());
//        System.out.println(it.next());
//        System.out.println(it.next());
//        System.out.println(it.next());//NoSuchElementException:请求的元素不存在

        //用while循环改进判断
        while (it.hasNext()) {
//            System.out.println(it.next());
            String s = it.next();
            System.out.println(s);
        }


    }
}

```

### 1.6 集合的使用步骤

步骤1:创建集合对象

步骤2:添加元素

​		步骤2.1:创建元素

​		步骤2.2:添加元素到集合

​		**合并:添加元素到集合**

步骤3:遍历集合

​		步骤3.1:通过集合对象获取迭代器对象

​		步骤3.2:通过迭代器对象的hasNext()方法判断是否还有元素

​		步骤3.3:通过迭代器对象的next()方法获取下一个元素

### 案例:Collection集合存储学生对象并遍历

```Java
package com.ling.Collection03;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class CollectionDemo {

    public static void main(String[] args) {
        //2.创建Collection集合对象
        Collection<Student> c = new ArrayList<Student>();

        //创建学生对象
        Student s1 = new Student("郭德纲",33);
        Student s2 = new Student("郭德",33);
        Student s3 = new Student("郭纲",33);

        c.add(s1);
        c.add(s2);
        c.add(s3);

        Iterator<Student> it = c.iterator();
        if (it.hasNext()) {
//            System.out.println(it.next());//Student{name='郭德纲', age=33}
            System.out.println(s1.getName()+","+s1.getAge());
            System.out.println(s2.getName()+","+s2.getAge());
            System.out.println(s3.getName()+","+s3.getAge());
        }
    }
}

```



## 2.List

### 2.1 List集合概述和特点

概述

- **有序集合**(也称为**序列**),用户可以精确控制列表中每个元素的插入位置.用户可以通过整数索引访问元素,并搜索列表中的元素.
- 与Set集合不同,列表通常不允许重复的元素

List集合特点

- 有序:存储和读取的元素顺序一致
- 可重复:存储的元素可以重复

```Java
package com.ling.List;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListDemo01 {

    /*
    List集合特点:
            有序:储存和取出的元素顺序一致
            可重复:储存的元素可以重复
     */

    public static void main(String[] args) {
        //添加集合对象
        List<String> list = new ArrayList<String>();

        //添加元素
        list.add("ling1");
        list.add("ling1");
        list.add("ling1");

        //输出集合对象
        System.out.println(list);

        //迭代器的方式遍历
        Iterator<?> it = list.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}

```



### 2.2 List集合特有方法

### add,remove,set,get

```Java
package com.ling.List;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListDemo02 {

    /*
    List集合特点:
            有序:储存和取出的元素顺序一致
            可重复:储存的元素可以重复
     */

    public static void main(String[] args) {
        //添加集合对象
        List<String> list = new ArrayList<String>();

        //添加元素
        list.add("ling1");
        list.add("ling2");
        list.add("ling1");

        //在此集合的指定位置插入指定元素
//        list.add(1, "hello");
//        list.add(4, "hello");//IndexOutOfBoundsException

        /*
        方式一:参数:o 要从此列表中删除的元素（如果存在）,返回boolean值
        方式二:参数index 删除指定索引处的元素,返回被删除的元素
         */
//        System.out.println(list.remove(1));

        //修改指定索引处的元素,返回被删除的元素
//        System.out.println("list.set(1,\"你好\") = " + list.set(1, "你好"));

        //返回指定索引处的元素
//        System.out.println(list.get(2));


        // 输出集合对象
//        System.out.println(list);

        //用for循环改进遍历
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}

```



案例:List集合存储学生对象并遍历

```Java
package com.ling.List;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListDemo03 {

    public static void main(String[] args) {
        //创建List集合对象
        List<Student> list = new ArrayList<Student>();

        //创建学生对象
        Student s1 = new Student("hello1",11);
        Student s2 = new Student("hello2",12);
        Student s3 = new Student("hello3",13);

        //把学生添加到集合
        list.add(s1);
        list.add(s2);
        list.add(s3);

        //迭代器方式遍历
        Iterator<Student> it = list.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }

        //for循环方式
        for (int i = 0; i < list.size(); i++) {
            Student s = list.get(i);
            System.out.println(s.getName() + "," + s.getAge());
        }
    }
}

```



### 2.3 并发修改异常

ConcurrentModificationException 并发修改异常

产生原因:

- 迭代器遍历的过程中,通过集合对象修改了集合中元素的长度,造成了迭代器获取元素中判断预期修改值和实际修改值不一致
- 实际修改集合的次数做了++,而预期修改集合的次数没有++,再次调用next方法的时候回判断实际和预期修改次数,不一样就会抛出并发修改异常

解决方案:

- 用for循环遍历,然后用集合对象做相应的操作即可

```txt
public interface List<E> extends Collection<E> {
    Iterator<E> iterator();
    boolean add(E e);
}

public abstract class  AbstractList<E>{
protect int modCount = 0;
}


public class ArrayList<E> extends AbstractList<E> implements List<E>{
    public Iterator<E> iterator() {
        return new Itr();
    }
    
    private class Itr implements Iterator<E> {
            int cursor;       // index of next element to return
            int lastRet = -1; // index of last element returned; -1 if no such
            int expectedModCount = modCount;
            /*
            modCount:实际修改集合的次数
            expectedModCount:预期修改集合的次数
            */

            public boolean add(E e) {
                ensureCapacityInternal(size + 1);  // Increments modCount!!
                elementData[size++] = e;
                return true;
            }
    
            public E next() {
                checkForComodification();
                int i = cursor;
                if (i >= size)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (i >= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i + 1;
                return (E) elementData[lastRet = i];
            }
    
            final void checkForComodification() {
                if (modCount != expectedModCount)
                    throw new ConcurrentModificationException();
            }
        }
}
```

```Java
package com.ling.List;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/*
并发修改异常
ConcurrentModificationException:此异常可能会被抛出的方法，已检测到的对象的并发修改时，这样的修改是不允许的。
 */
public class ListDemo04 {

    public static void main(String[] args) {
        //添加集合对象
        List<String> list = new ArrayList<String>();

        //添加元素
        list.add("ling1");
        list.add("ling2");
        list.add("ling1");

        //遍历集合,得到每一个元素,看有没有"word"这个元素,如果有就添加一个"hello"元素
//        Iterator<String> it = list.iterator();
//        while (it.hasNext()) {
//            String s = it.next();
//            if (s.equals("ling2")) {
//                list.add("hello");
//            }
//        }

        for (int i = 0; i < list.size(); i++) {
            String s = list.get(i);
            if (s.equals("ling2")) {
                list.add("hello");//在尾部追加
            }
        }

        //输出集合对象
        System.out.println(list);
    }
}

```



### 2.4 列表迭代器

**expectedModCount = modCount;**

```Java
package com.ling.List;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

//ListIterator:列表迭代器
public class ListDemo05 {

    public static void main(String[] args) {
        //创建集合对象
        List<String> list = new ArrayList<String>();

        //添加元素
        list.add("ling1");
        list.add("ling2");
        list.add("ling3");

        //通过List集合的ListIterator()方法得到
//        ListIterator<String> lit = list.listIterator();
//        while (lit.hasNext()) {
//            String s = lit.next();
//            System.out.println(s);
//        }
//
//        System.out.println("------");
//
//        while (lit.hasPrevious()) {
//            String s = lit.previous();
//            System.out.println(s);
//        }

        ListIterator<String> lit = list.listIterator();
        while (lit.hasNext()) {
            String s = lit.next();
            System.out.println(s);
        }
    }
}

```



```txt
public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                ArrayList.this.add(i, e);
                cursor = i + 1;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
```



### 2.5 增强for循环:简化数组和Collection集合的遍历

增强for循环:简化数组和Collection集合的遍历

**内部原理是一个Iterator迭代器**

#### 案例:四种方式遍历List集合

```Java
package com.ling.List;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

//案例:List集合存储学生对象用三种方式遍历
public class ListDemo07 {

    public static void main(String[] args) {
        //创建集合对象
        List<String> list = new ArrayList<String>();

        //添加元素
        list.add("ling1");
        list.add("ling2");
        list.add("ling3");

        //方式一:迭代器遍历
        Iterator<String> it = list.listIterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }

        System.out.println("------------");

        //方式二:for ()循环
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
        System.out.println("------------");

        //方式三:ListIterator
        ListIterator<String> lit=list.listIterator();
        while (lit.hasNext()) {
            System.out.println(lit.next());
        }

        System.out.println("------------");

        //方式四:增强for
        for (String s : list) {
            System.out.println(s);
        }
    }
}

```

### 2.6 数据结构栈

数据结构是**计算机存储,组织数据的方式.是指相互之间存在一种或多种特定关系的数据元素的集合.**

通常情况下:精心选择的数据结构可以带来更高的运行或者储存效率.

栈:先进后出 压/进栈 弹/出栈



### 2.7 数据结构队列

队列:先进先出 入队列,出队列

### 2.8 常见数据结构之数组

数组是一种**查询快,增删慢的**模型

- 查询数据通过索引定位,查询任意数据耗时相同,查询效率高.
- 删除数据时,要将原始数据删除,同时后面每个数据前移,删除效率低.
- 添加数据时,添加位置后的每个数据后移,再添加元素,添加效率极低.



### 2.9 常见数据结构之链表

节点的存储位置(地址),存储的具体数据,下一个节点的地址

**头结点**,节点指向空地址(表示结束)

![image-20201122203625968](https://i.loli.net/2020/11/22/s4FfrmcHgolpe27.png)

- 链表是一种**增删快**的模型(对比数组)

- 链表是一种**查询慢**的模型(对比数组)

查询D是否存在,必须从头(head)开始查询

### 2.11 List集合的子类特点

List集合常用子类:ArrayList,LinkedList

- ArrayList:底层数据结构是数组,查询快,增删慢;
- LinkedList:底层数据结构是链表,查询慢,增删快.

```Java
package com.ling.List02;

import java.util.ArrayList;
import java.util.LinkedList;

//练习:ArrayList,LinkedList完成存储字符串并遍历
public class ListDemo {
    public static void main(String[] args) {

        ArrayList<String> arrayList = new ArrayList<String>();
        arrayList.add("hello1");
        arrayList.add("hello2");
        arrayList.add("hello3");

        for (String s : arrayList) {
            System.out.println(s);
        }
        System.out.println("-----------");

        LinkedList<String> linkedList = new LinkedList<String>();
        linkedList.add("ling1");
        linkedList.add("ling2");
        linkedList.add("ling3");

        for (String s : linkedList) {
            System.out.println(s);
        }
    }
}

```



#### 案例:ArrayList集合存储学生对象三种方式遍历

**Student.java**

```Java
package com.ling.List02;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

**ArrayListDemo.java**

```java
package com.ling.List02;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class ArrayListDemo {

    public static void main(String[] args) {
        ArrayList<Student> ar = new ArrayList<Student>();
        Student s1 = new Student("ling1", 1);
        Student s2 = new Student("ling2", 2);
        Student s3 = new Student("ling3", 3);
        ar.add(s1);
        ar.add(s2);
        ar.add(s3);

        //1.迭代器ListIterator和Iterator
        ListIterator<Student> lit = ar.listIterator();
        while (lit.hasNext()) {
            System.out.println(lit.next());
        }
        System.out.println("------------");

        //2.for循环
        for (int i = 0; i < ar.size(); i++) {
            System.out.println(ar.get(i));
        }
        System.out.println("------------");

        //3.增强for循环
        for (Student s : ar) {
            System.out.println(s.getName()+","+s.getAge());

        }
    }
}

```



### 2.12 LinkedList集合的特有功能

### **addFirst,addLast,getFirst,getLast,removeFirst,removeLast**

```Java
package com.ling.List02;

import java.util.LinkedList;

public class LinkedListDemo {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<String>();
        list.add("ling1");
        list.add("ling2");
        list.add("ling3");

//        list.addFirst("1111");
//        list.addLast("2222");
//        System.out.println(list.getFirst());
//        System.out.println(list.getLast());

        System.out.println(list.remove());
//        System.out.println(list.removeFirst());
//        System.out.println(list.removeLast());

        System.out.println(list);

    }
}

```



## 3.Set

### 3.1 Set集合概述和特点

特点:

- 不包含重复元素的集合
- 没有带索引的方法,所以不能使用普通for循环遍历

HashSet:对集合的迭代顺序不作任何保证

```Java
package com.ling.Set01;

import java.util.HashSet;
import java.util.Set;

public class SetDemo {

    public static void main(String[] args) {
        //HashSet:对集合的迭代顺序不作任何保证
        Set<String> set = new HashSet<String>();
        set.add("ling1");
        set.add("ling2");
        set.add("ling3");
        //你包含重复元素的集合
        set.add("ling1");

        //遍历
        for (String s : set) {
            System.out.println(s);
        }
    }
}

```



### 3.2 哈希值

哈希值:**是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值.**

Object类中有一个方法可以获取对象的哈希值

- public int hashCode():返回对象的哈希码值

对象的哈希值特点:

- **同一个对象多次调用hashCode()方法返回的哈希值是相同的**
- 默认情况下,不同对象的哈希值是不同的.而重写hashCode()方法,可以实现让不同对象的哈希值相同.

```Java
package com.ling.Set01;

public class HashDemo {
    public static void main(String[] args) {
        
        Student s1 = new Student("ling",11);
        Student s2 = new Student("ling",11);

        //同一个对象多次调用hashCode()方法返回的哈希值是相同的
        System.out.println(s1.hashCode());
        //默认情况下,不同对象的哈希值是不相同的
        //通过方法重写,可以实现不同对象的哈希值是相同的
        System.out.println(s2.hashCode());

        System.out.println("lng`".hashCode());//3326427
        System.out.println("22`".hashCode());//49696
		
        //这两个特殊,其他的字符串的hashCode都不同
        System.out.println("重地".hashCode());//1179395
        System.out.println("通话".hashCode());//1179395

        System.out.println("爱你".hashCode());//926543
        System.out.println("爱您".hashCode());//930967


    }
}

```



### 3.3 HashSet集合概述和特点

HashSet集合特点:
    1.**底层的数据结构是哈希表**,哈希表是根据关键码值(Key value)而直接进行访问的[数据结构](https://baike.baidu.com/item/数据结构/1450)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做[散列函数](https://baike.baidu.com/item/散列函数/2366288)，存放记录的[数组](https://baike.baidu.com/item/数组/3794097)叫做[散列表](https://baike.baidu.com/item/散列表/10027933)。
    2.对集合的迭代顺序不作任何保证,也就是说不保证储存和取出的元素顺序不一致
    3.没有带索引的方法,所以不能使用普通for循环遍历
    4.由于是Set集合,所以是不包含重复元素的集合

```Java
package com.ling.Set01;

import java.util.HashSet;

/*
    HashSet集合特点:
        1.底层的数据结构是哈希表
        2.对集合的迭代顺序不作任何保证,也就是说不保证储存和取出的元素顺序不一致
        3.没有带索引的方法,所以不能使用普通for循环遍历
        4.由于是Set集合,所以是不包含重复元素的集合
 */
public class HashSetDemo01 {
    public static void main(String[] args) {
        //创建集合对象
        HashSet<String> hs = new HashSet<String>();

        //添加元素
        hs.add("hello1");
        hs.add("hello3");
        hs.add("hello2");
        //元素顺序不一致

        //不包含重复元素的集合
        hs.add("hello2");

        for (String s : hs) {
            System.out.println(s);
        }
    }
}

```



### 3.4 HashSet集合保证元素唯一性源码分析

```txt
//创建集合对象
HashSet<StudentHashset> hs = new HashSet<StudentHashset>();

//添加元素
StudentHashset s1 = new StudentHashset("hello1",11);
StudentHashset s2 = new StudentHashset("hello2",22);
StudentHashset s3 = new StudentHashset("hello3",33);

---------------------------------------------------------------------

public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

//hash值和元素的hashCode()方法相关
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;

    //如果哈希表未初始化,就对其进行初始化
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;

    //根据对象的哈希值计算对象的存储位置,如果该位置没有元素,就储存元素
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;

        /*
            存入的元素和以前的元素比较哈希值
                如果哈希值不同,会继续向下执行,把元素添加到集合
                如果哈希值相同,会调用对象的equals()方法比较
                    如果返回false,会继续向下执行,把元素添加到集合
                    如果返回true,说明元素重复,不存储
        */


        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}

```



![image-20201124212657710](https://i.loli.net/2020/11/24/Uw4DKIHtMWYQGdb.png)



HashSet集合存储元素:要保证元素唯一,需要重写hashCode()和equals()



### 3.5 常见数据结构之哈希表

哈希表

- JDK8之前,底层采用**数组+链表**实现,可以说是一个**元素为链表的数组**;
- JDK8之后,在长度比较长的时候,底层实现了优化;

哈希表是如何保证元素唯一性的:

1.六个字符串存到哈希表里

|         | 哈希值    | 哈希值对2取余 |
| ------- | --------- | ------------- |
| "hello" | 99162322  | 99162322%2=2  |
| "world" | 113318802 | 2             |
| "java"  | 3254818   | 2             |
| "world" | 113318802 | 2             |
| "通话"  | 1179395   | 3             |
| "重地"  | 1179395   | 3             |

HashSet()默认构造长度为16,0~15

2.如何把哈希值存到数组里面,转换成0~15数组之间的值

哈希值对2取余

3.存到数组里

哈希值对2取余得到的值

- "hello"哈希值对2取余是2,2的位置没有元素直接存入
- "world",索引2已经有元素了,比较哈希值(hashCode),哈希值不相同,所以"world"通过链表hello连接world
- "java",也是2,和多个元素比较哈希值,哈希值不相同,world节点下面连接java
- "world"先比较哈希值,哈希值相同然后比较内容,内容也相同,重复元素就不存储

"通话"哈希值对2取余得到3,数组3位置没有元素,直接存储

"重地"哈希值对2取余也是3,先比较哈希值,哈希值相同,比较内容,内容不相同,"通话"节点连接"重地"



#### 案例:HashSet集合存储学生对象并遍历

StudentHashSet.Java

```Java
package com.ling.Set01;

import java.util.Objects;

public class StudentHashset {

    private String name;
    private int age;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        StudentHashset that = (StudentHashset) o;
        return age == that.age &&
                Objects.equals(name, that.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    public StudentHashset() {
    }

    public StudentHashset(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

HashSetDemo01,Java

```Java
package com.ling.Set01;

import java.util.HashSet;
import com.ling.Set01.StudentHashset;


public class HashSetDemo02 {
    public static void main(String[] args) {


        //创建集合对象
        HashSet<StudentHashset> hs = new HashSet<StudentHashset>();

        StudentHashset s1 = new StudentHashset("hello1",11);
        StudentHashset s2 = new StudentHashset("hello2",22);
        StudentHashset s3 = new StudentHashset("hello3",33);

        //重复元素,可以存储成功;需要重写hashCode()和equals()方法
        StudentHashset s4 = new StudentHashset("hello2",22);

        //添加元素
        hs.add(s1);
        hs.add(s2);
        hs.add(s3);

        for (StudentHashset s : hs) {
            System.out.println(s.getName()+","+s.getAge());
        }
    }
}

```



### 3.6 LinkedHashSet集合概述和特点

LinkedHashSet集合的特点:

- 哈希表和链表实现的Set接口,具有可预测的迭代次序
- 由链表保证元素有序,也就是说元素的储存和取出顺序是一致的
- 由哈希表保证元素唯一,也就是说没有重复元素

```Java
package com.ling.Set02;

import java.util.LinkedHashSet;

public class LinkedHashSetDemo {

    public static void main(String[] args) {
        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<String>();
        linkedHashSet.add("hello");
        linkedHashSet.add("java");
        linkedHashSet.add("rose");
        
        linkedHashSet.add("hello");

        for (String s : linkedHashSet) {
            System.out.println(s);
        }

    }
}

```



### 3.7 TreeSet集合概述和特点

TreeSet集合特点:

1. 元素有序,这里的顺序不是指储存和取出的顺序,而是按照一定的规则进行排序,具体排序方式取决于构造方法TreeSet():根据其元素的自然排序进行排序

   TreeSet(Comparator comparator):根据指定的比较器进行排序

2. 没有带索引的方法,所以不能使用普通for循环遍历

3. 由于是Set集合,所以不包含重复元素的集合



```Java
package com.ling.Set02;

import java.util.TreeSet;

public class TreeSetDemo {
    public static void main(String[] args) {
        //这里用int会报错,应该用int 的包装类Integer,1.5以后自动拆箱装箱
        TreeSet<Integer> treeSet = new TreeSet<Integer>();

        treeSet.add(111);
        treeSet.add(161);
        treeSet.add(114);
        treeSet.add(131);
        treeSet.add(121);

        //Set集合不允许出现重复元素
        treeSet.add(111);

        for (Integer i : treeSet) {
            System.out.println(i);
        }
    }
}

```

### 3.8 自然排序Comparable的使用

- 存储学生对象并遍历,创建TreeSet集合使用**无参构造方法**
- 要求:按照年龄从小到大排序,年龄相同时,按照姓名的字母顺序排序

**Student.Java**

```java
package com.ling.Set02;

public class Student implements Comparable<Student>{
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public int compareTo(Student s) {
        //只存储一个元素,其他元素是重复的就不会添加到集合中
//        return 0;
        //升序,1是正数,s2比s1大,按照我们添加的顺序排序
//        return 1;
        //倒叙
//        return -1;
        //按照年龄从小到大排序
        /*
        this是s2,s是s1
        年龄按升序排列
         */
        int num = this.age - s.age;
        //年龄按倒叙
//        int num = s.age - this.age;
        //年龄相同时,按照姓名的字母顺序排序
        int num2 = num == 0 ? this.name.compareTo(s.name) : num;
        return num2;
    }

}

```



**TreeSetDemo01.java**

```Java
package com.ling.Set02;

import java.util.TreeSet;
/*
- 存储学生对象并遍历,创建TreeSet集合使用无参构造方法
- 要求:按照年龄从小到大排序,年龄相同时,按照姓名的字母顺序排序
报错:Comparable
解决:实现Comparable接口
 */


public class TreeSetDemo02 {
    public static void main(String[] args) {
        //这里用int会报错,应该用int 的包装类Integer,1.5以后自动拆箱装箱
        TreeSet<Student> treeSet = new TreeSet<Student>();

        Student s1 = new Student("xishi",22);
        Student s2 = new Student("ciaochan",12);
        Student s3 = new Student("wangzhaojun",32);
        Student s4 = new Student("yangyuhuan",42);

        Student s5 = new Student("xiaoqq",32);
        //去除重复元素
        Student s6 = new Student("xiaoqq",32);

        treeSet.add(s1);
        treeSet.add(s2);
        treeSet.add(s3);
        treeSet.add(s4);
        treeSet.add(s5);
        treeSet.add(s6);

        for (Student i : treeSet) {
            System.out.println(i);
        }
    }
}

```

结论:

- 用TreeSet集合储存自定义对象,无参构造方法使用的是**自然排序**对元素进行排序的
- 自然排序,就是**让元素所属的类实现Comparable接口**,重写compareTo(To)方法
- 重写方法时,一定要注意排序规则必须按照要求的主要条件和次要条件来写

### 3.9 比较器排序Comparator的使用

- 存储学生对象并遍历,创建TreeSet集合使用**带参构造方法**
- 要求:按照年龄从小到大排序,年龄相同时,按照姓名的字母顺序排序

Student.java nama,age;get/set,有参构造器,无参构造器

```Java
package com.ling.Set03;

import java.util.Comparator;
import java.util.TreeSet;
/*
- 存储学生对象并遍历,创建TreeSet集合使用**带参构造方法**
- 要求:按照年龄从小到大排序,年龄相同时,按照姓名的字母顺序排序
 */
public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet<Student> treeSet = new TreeSet<Student>(new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                /*
                this.age - s.age
                s1,s2
                s是s1(第一个元素),this是s2(第二个元素)
                 */
                //升序
                int num = s1.getAge() - s2.getAge();
                int num1 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;
                return num1;
            }
        });

        Student s1 = new Student("xishi",22);
        Student s2 = new Student("ciaochan",12);
        Student s3 = new Student("wangzhaojun",32);
        Student s4 = new Student("yangyuhuan",42);

        Student s5 = new Student("xiaoqq",32);
        //去除重复元素
        Student s6 = new Student("xiaoqq",32);

        treeSet.add(s1);
        treeSet.add(s2);
        treeSet.add(s3);
        treeSet.add(s4);
        treeSet.add(s5);
        treeSet.add(s6);

        for (Student i : treeSet) {
            System.out.println(i);
        }
    }
}

```

结论:

- 用TreeSet集合储存自定义对象,带参构造方法使用的是**比较器排序**对元素进行排序
- 比较器排序,就是**让集合构造方法接收Comparator的实现类对象**,重写compare(To1,To2)方法
- 重写方法时,一定注意排序规则必须按照要求的主要条件和次要条件来写



### 案例:成绩排序

需求:用TreeSet集合存储多个学生信息(姓名，语文成绩，数学成绩)，并遍历该集合
要求:按照总分从高到低出现

Student.java (name,chinese,math 姓名,语文数学成绩)

```Java
package com.ling.Set04;

public class Student {
    private String name;
    private int chinese;
    private int math;

    public Student() {
    }

    public Student(String name, int chinese, int math) {
        this.name = name;
        this.chinese = chinese;
        this.math = math;
    }



    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getChinese() {
        return chinese;
    }

    public void setChinese(int chinese) {
        this.chinese = chinese;
    }

    public int getMath() {
        return math;
    }

    public void setMath(int math) {
        this.math = math;
    }

    public int getSun() {
        return this.chinese+this.math;
    }
}

```



Demo

```Java
package com.ling.Set04;


import com.ling.Set04.Student;

import java.util.Comparator;
import java.util.TreeSet;

/*
需求:用TreeSet集合存储多个学生信息(姓名，语文成绩，数学成绩)，并遍历该集合
要求:按照总分从高到低出现
 */
public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet<Student> treeSet = new TreeSet<Student>(new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                int num = s2.getSun() - s1.getSun();
                int num2 = num == 0 ? s1.getChinese() - s2.getChinese():num;
                int num3 = num2 == 0 ? s1.getName().compareTo(s2.getName()):num2;
                return num3;
            }
        });

        Student s1 = new Student("ling1", 91, 99);
        Student s2 = new Student("ling2", 93, 98);
        Student s3 = new Student("ling3", 92, 90);
        Student s4 = new Student("ling4", 94, 91);

        Student s5 = new Student("ling5", 90, 95);
//        Student s6 = new Student("ling5", 90, 95);
        Student s6 = new Student("ling6", 90, 95);


        treeSet.add(s1);
        treeSet.add(s2);
        treeSet.add(s3);
        treeSet.add(s4);
        treeSet.add(s5);
        treeSet.add(s6);

        for (Student i : treeSet) {
            System.out.println(i.getName()+","+i.getChinese()+","+i.getMath()+","+i.getSun());
        }
    }
}

```



### 案例:不重复的随机数

需求:编写一个程序，获取10个1-20之间的随机数，要求随机数不能重复，并在控制台输出

```Java
package com.ling.Set04;

import java.util.HashSet;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;

/*
需求:编写一个程序，获取10个1-20之间的随机数，要求随机数不能重复，并在控制台输出

 */
public class SetDemo {
    public static void main(String[] args) {

        //HashSet不会排序,TreeSet会排序
//        Set<Integer> set = new HashSet<Integer>();
        Set<Integer> set = new TreeSet<Integer>();

        Random r = new Random();

        //判断集合长度是否小于10
        while (set.size() < 10) {
            int num = r.nextInt(20) + 1;
            set.add(num);
        }

        for (Integer i : set) {
            System.out.println(i);
        }
    }
}

```



## 泛型 

### 4.1 泛型概述

泛型:是JDK5中引入的特性,它提供了编译时类型安全监测机制,该机制允许在编译时监测到非法的类型,它的本质是**参数化类型**,也就是说所操作的数据类型被指定为一个参数

一提到参数,最熟悉的就是定义方法时有形参,然后调用此方法时传递实参.那么参数化类型怎么理解呢?

顾名思义,就是将类型由原来的具体的类型参数化,然后在使用/调用时传入具体的类型.

这种参数类型可以用在类,方法和接口中,分别被称为泛型类,泛型方法,泛型接口

格式:

- <类型>:定义一种类型的格式,这里的类型可以看成是形参
- <类型1,类型2>:指定多种类型的格式,多种类型之间用逗号隔开.这里的类型可以看成是形参
- 将来具体调用的时候给定的类型可以看成是实参,并且实参的类型只能是引用数据类型

好处:

1.把运行时期的问题提前到编译期间 ClassCastException

2.避免了强制类型转化



### 4.2 泛型类

Generic.java

```Java
package com.ling.Generic;

//T,E,K,V等参数类型的参数常用语表示泛型
public class Generic<T> {
    private T t;

    public T getT() {
        return t;
    }

    public void setT(T t) {
        this.t = t;
    }
}

```



GenericDemo.Java

```Java
package com.ling.Generic;

public class GenericDemo {
    public static void main(String[] args) {

        Student s = new Student();
        s.setAge(11);
        System.out.println(s.getAge());

        Teacher t = new Teacher();
        t.setName("精灵");
        System.out.println(t.getName());
        System.out.println("---------------------------");

        Generic<String> g1 = new Generic<String>();
        g1.setT("化工");
        System.out.println(g1.getT());

        Generic<Integer> g2 = new Generic<Integer>();
        g2.setT(22);
        System.out.println(g2.getT());

        Generic<Boolean> g3 = new Generic<Boolean>();
        g3.setT(true);
        System.out.println(g3.getT());
    }
}

```



### 4.3 泛型方法

#### 泛型类

```Java
package com.ling.Generic03;

//public class Generic {
//
//    public void show(String s) {
//        System.out.println(s);
//    }
//
//    public void show(Integer i) {
//        System.out.println(i);
//    }
//
//    public void show(Boolean b) {
//        System.out.println(b);
//    }
//
//}

//泛型类改进
//public class Generic<T>
//{
//    public void show(T t) {
//        System.out.println(t);
//    }
//}

//泛型方法改进
public class Generic{
    public <T> void show(T t) {
        System.out.println(t);
    }
}
```



#### 测试类

```Java
package com.ling.Generic03;

public class GenericDemo {

    public static void main(String[] args) {
//        Generic g = new Generic();
//        g.show("烦死垃圾");
//        g.show(30);
//        g.show(true);
//        g.show(30.33);


//        Generic<String> g1 = new Generic<String>();
//        g1.show("干了");
//
//        Generic<Integer> g2 = new Generic<Integer>();
//        g2.show(32);
//
//        Generic<Boolean> g3 = new Generic<Boolean>();
//        g3.show(true);

        Generic g = new Generic();
        g.show("帆赛");
        g.show(11);
        g.show(11.1111);
        g.show(true);
        g.show('2');

    }

}

```





### 4.4 泛型接口

#### 定义接口 Generic

```Java
package com.ling.Generic02;

public interface Generic<T> {
    void show(T t);
}

```



#### 接口实现类 GenericImpl

```Java
package com.ling.Generic02;

public class GenericImpl<T> implements Generic<T>{

    public void show(T t) {
        System.out.println(t);
    }
}

```



#### 测试类 GenericDemo02

```Java
package com.ling.Generic02;

public class GenericDemo02 {

    public static void main(String[] args) {
        Generic<String> g1 = new GenericImpl<String>();
        g1.show("就菲拉斯");

        Generic<Integer> g2 = new GenericImpl<Integer>();
        g2.show(42);
    }
}

```



### 4.5 类型通配符

类型通配符:<?>
    List<?>:表示元素类型未知的List,它的元素可以匹配任何的类型
    这种带通配符的List仅表示它是各种泛型List的父类,并不能吧元素添加到其中

类型通配符上限:<? extends 类型>
    List<? extends Number>:他表示的类型是Number或者其子类型

类型通配符下限:<? super 类型>
    List<? suuper Number>:他表示的类型是Number或者其父类型



```Java
package com.ling.Generic04;

/*
    类型通配符:<?>
        List<?>:表示元素类型未知的List,它的元素可以匹配任何的类型
        这种带通配符的List仅表示它是各种泛型List的父类,并不能吧元素添加到其中

    类型通配符上限:<? extends 类型>
        List<? extends Number>:他表示的类型是Number或者其子类型

    类型通配符下限:<? super 类型>
        List<? suuper Number>:他表示的类型是Number或者其父类型


 */

import java.util.ArrayList;
import java.util.List;

public class GenericDemo {
    public static void main(String[] args) {
        //类型通配符:<?>
        List<?> list1 = new ArrayList<Object>();
        List<?> list2 = new ArrayList<Number>();
        List<?> list3 = new ArrayList<Integer>();

        //类型通配符上限:<? extends 类型>
//        List<? extends Number> list4 = new ArrayList<Object>();
        List<? extends Number> list5 = new ArrayList<Number>();
        List<? extends Number> list6 = new ArrayList<Integer>();

        //类型通配符下限:<? super 类型>
        List<? super Number> list7 = new ArrayList<Object>();
        List<? super Number> list8 = new ArrayList<Number>();
//        List<? super Number> list9 = new ArrayList<Integer>();



    }
}

```



### 4.6 可变参数

可变参数又称参数个数可变,用作方法的形参出现,那么方法参数个数就是可变的了

范例:public static int sum(int... a)

注意事项:

- 这里的变量其实是一个数组
- 如果一个方法有多个参数,包含可变参数,可变参数要放在最后



```Java
package com.ling.Generic04;

public class ArgsDemo01 {
    public static void main(String[] args) {
        System.out.println(sum(1, 23));
        System.out.println(sum(1, 23, 44));
        System.out.println(sum(1, 23, 44, 33));
    }

    public static int sum(int... a) {
        int sum = 0;
        for (int i : a) {
            sum+=i;
        }
        return sum;
    }


//    public static int sum(int a, int b) {
//        return a+b;
//    }
//
//    public static int sum(int a, int b,int c) {
//        return a+b+c;
//    }
//
//    public static int sum(int a, int b,int c ,int d) {
//        return a+b+c+d;
//    }
}

```



### 4.7 可变参数的使用

Arrays工具类中有一个静态方法:

- ​		public static <T> List<T> asList(T... a):返回由指定数组支持的固定大小的列表
- **返回的集合不能做增删操作,可以做修改操作**

List接口中有一个静态方法:

- ​		public static <E> List<E> of (E... elements):返回包含任意数量元素的不可变列表
- **返回的集合不能做增删改查操作**

Set接口中有一个静态方法:

- ​		Public static <T> List<T> asList (E... elements);返回一个包含任意数量元素的不可变集合
- **再给元素的时候,不能给重复的元素**

```Java
package com.ling.Args;

import java.awt.*;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

/*
    Arrays工具类中有一个静态方法:

​		public static <T> List<T> asList(T... a):返回由指定数组支持的固定大小的列表

List接口中有一个静态方法:

​		public static <E> List<E> of (E... elements):返回包含任意数量元素的不可变列表

Set接口中有一个静态方法:

​		Public static <T> List<T> asList (E... elements);返回一个包含任意数量元素的不可变集合
 */
public class ArgsDemo02 {
    public static void main(String[] args) {

        //public static <T> List<T> asList(T... a):返回由指定数组支持的固定大小的列表
//        List<String> list = Arrays.asList("hello", "java", "world");

//        list.add("javaee");//UnsupportedOperationException
//        list.remove("java");//UnsupportedOperationException
//        list.set(1, "javaee");//UnsupportedOperationException
//        System.out.println(list);

//        public static <E> List<E> of (E... elements):返回包含任意数量元素的不可变列
	//of方法测试无法测试List.of报错,找不到相应的方法
    }


}

```





## Map 

### 5.1 Map集合概述和使用

概述:

- interface Map<K,V> K:键的类型 V:值的类型
- 将键映射到值的对象;不能包含重复的键;每个键可以映射到最多一个值

创建Map集合的对象:

- 多态的方式
- 具体的实现类HashMap

```Java
package com.ling.Map;

import java.util.HashMap;
import java.util.Map;

public class MapDemo01 {

    public static void main(String[] args) {
        //创建集合对象
        Map<String, String> map = new HashMap<String, String>();

        //V put(K key,V value)将指定的值与映射中的指定键相关联
        map.put("ling1", "方法的1");
        map.put("ling2", "方法的2");
        map.put("ling3", "方法的3");
        map.put("ling3", "方法的4");

        //输出集合对象
        System.out.println(map);

    }
}

```



### 5.2 Map集合的基本功能

#### 常用方法:put,remove,clear,containsKey,isEmpty,size

```Java
package com.ling.Map;

import java.util.HashMap;
import java.util.Map;

public class MapDemo02 {

    public static void main(String[] args) {
        //创建集合对象
        Map<String, String> map = new HashMap<String, String>();

        //V put(K key,V value),添加元素
        map.put("ling1", "方法的1");
        map.put("ling2", "方法的2");
        map.put("ling3", "方法的3");

        //V remove(Object key) :根据键删除键值对元素
//        map.remove("ling2");
//        map.remove("ling4");//如果没有返回null

        //void clear():移除所有的键值对元素
//        map.clear();

        //boolean containsKey/Value(Object key):判断集合是否包含指定的键/键
//        map.containsKey("ling1");//包含返回true
//        map.containsValue("方法的3");

        //判断集合是否为空
//        map.isEmpty();

        //集合的长度,也就是集合中键值对的个数
//        map.size();

        //输出集合对象
        System.out.println(map);


    }
}

```



### 5.3 Map集合的获取功能

- V get(Object key):根据键获取值，键不存在返回的值为空
- Set<K> keySet()：获取所有键的集合
- Collection<v> values():获取所有值的集合



### 5.4 Map集合的遍历（方式1）

根据key找value

```Java
package com.ling.Map;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDemo03 {

    public static void main(String[] args) {
        //创建集合对象
        Map<String, String> map = new HashMap<String, String>();

        //V put(K key,V value)将指定的值与映射中的指定键相关联
        map.put("ling1", "方法的1");
        map.put("ling2", "方法的2");
        map.put("ling3", "方法的3");

        //获取所有键的集合，用keySet（）方法实现
        Set<String> keySet = map.keySet();
        //遍历键的集合，获取到每一个键，用增强for实现
        for (String key : keySet) {
            //根据键去找值，用get（Object key）方法实现
            String value = map.get(key);
            System.out.println(key+","+value);
        }
    }
}

```





### 5.5 Map集合的遍历（方式2）

获取所有键值对对象的集合，遍历键值对对象，得到每一个键值对对象，根据键值对对象获取键和值

```java
package com.ling.Map;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDemo04 {

    public static void main(String[] args) {
        //创建集合对象
        Map<String, String> map = new HashMap<String, String>();

        //V put(K key,V value)将指定的值与映射中的指定键相关联
        map.put("ling1", "方法的1");
        map.put("ling2", "方法的2");
        map.put("ling3", "方法的3");

        //获取所有键值对对象的集合
        Set<Map.Entry<String,String>> entrySet = map.entrySet();
        //遍历键值对对象的集合，得到每一个键值对对象
        for ( Map.Entry<String,String> me : entrySet) {
            String key = me.getKey();
            String value = me.getValue();
            System.out.println(key+","+value);
        }

    }
}

```



### 案例： HashMap集合练习之键是string值是student

```java
package com.ling.Map;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDemo05 {

    public static void main(String[] args) {

        HashMap<String, Student> map = new HashMap<String, Student>();
        Student ling1 = new Student("ling1",11);
        Student ling2 = new Student("ling2",22);
        Student ling3 = new Student("ling3",33);

        map.put("HashMap1", ling1);
        map.put("HashMap2", ling2);
        map.put("HashMap3", ling3);

        //方式1：键找值
        Set<String> keySet = map.keySet();
        System.out.println(keySet);
        for (String key : keySet) {
            Student value = map.get(key);
            System.out.println(key+","+value.getName()+","+value.getAge());
        }
        System.out.println("------------");

        //方式2：键值对对象找键和值
        Set<Map.Entry<String,Student>> entrySet = map.entrySet();
        for (Map.Entry<String, Student> me : entrySet) {
            String key = me.getKey();
            Student value = me.getValue();
            System.out.println(key+","+value.getName()+","+value.getAge());

        }


    }
}

```



### 案例： HashMap集合练习之键是student值是string

```java
package com.ling.Map;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDemo06 {

    public static void main(String[] args) {

        HashMap<Student,String > hm = new HashMap<Student,String>();
        Student ling1 = new Student("ling1",11);
        Student ling2 = new Student("ling2",22);
        Student ling3 = new Student("ling3",33);
        Student ling4 = new Student("ling3",33);

        hm.put(ling1,"北京");
        hm.put(ling2,"上海");
        hm.put(ling3,"广东");
        hm.put(ling4,"杭州");

        Set<Student> keySet = hm.keySet();
        for (Student key : keySet) {
            String value = hm.get(key);
            System.out.println(key.getName()+","+key.getAge()+","+value);
        }


    }
}

```



### 案例：ArrayList集合存储HashMap集合并遍历

```java
package com.ling.Map;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

public class MapDemo07 {
    public static void main(String[] args) {
        //创建ArrayList集合
        ArrayList<HashMap<String, String>> arrayList = new ArrayList<HashMap<String, String>>();

        //创建HashMap集合，并添加键值对元素
        HashMap<String, String> hm1 = new HashMap<String, String>();
        hm1.put("孙策", "大乔");
        hm1.put("周瑜", "小乔");
        //把HashMap作为元素添加到ArrayList集合
        arrayList.add(hm1);

        //创建HashMap集合，并添加键值对元素
        HashMap<String, String> hm2 = new HashMap<String, String>();
        hm2.put("孙尚香", "刘备");
        hm2.put("杨过", "小龙女");
        //把HashMap作为元素添加到ArrayList集合
        arrayList.add(hm2);

        //创建HashMap集合，并添加键值对元素
        HashMap<String, String> hm3 = new HashMap<String, String>();
        hm3.put("令狐冲", "任盈盈");
        hm3.put("妲己", "亚瑟");
        //把HashMap作为元素添加到ArrayList集合
        arrayList.add(hm3);

        //遍历ArrayList集合
        for (HashMap<String, String> hm : arrayList) {
            Set<String> keySet = hm.keySet();
            for (String key : keySet) {
                String value = hm.get(key);
                System.out.println(key + "," + value);
            }
        }

    }
}

```



### 案例：ArrayList集合存储HashMap集合并遍历

## 

```java
package com.ling.Map;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;

public class MapDemo08 {
    public static void main(String[] args) {
        //创建HashMap集合
        HashMap<String, ArrayList<String>> hm = new HashMap<String, ArrayList<String>>();

        //创建ArrayList集合，并添加元素
        ArrayList<String> sgyy = new ArrayList<String>();
        sgyy.add("吕布");
        sgyy.add("赵云");
        //把ArrayList作为元素添加到HashMap集合
        hm.put("三国演义", sgyy);

        //创建ArrayList集合，并添加元素
        ArrayList<String> shz = new ArrayList<String>();
        sgyy.add("宋江");
        sgyy.add("李逵");
        //把ArrayList作为元素添加到HashMap集合
        hm.put("水浒传", shz);

        //创建ArrayList集合，并添加元素
        ArrayList<String> xyj = new ArrayList<String>();
        sgyy.add("孙悟空");
        sgyy.add("猪八戒");
        //把ArrayList作为元素添加到HashMap集合
        hm.put("西游记", xyj);

        //遍历HashMap集合  
        Set<String> keySet = hm.keySet();
        for (String key : keySet) {
            System.out.println(key);
            ArrayList<String> value = hm.get(key);
            for (String s : value) {
                System.out.println("\t" + s);
            }
        }
    }
}

```

### 案例：统计字符串中每个字符出现的次数

```java
package com.ling.Map;

import java.util.*;

public class MapDemo9 {
    public static void main(String[] args) {
        //键盘录入一个字符串
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个字符串：");
        String line = sc.nextLine();

        //创建HashMap集合，键是Charact，值是Integer
//        HashMap<Character, Integer> hm = new HashMap<Character, Integer>();
        TreeMap<Character, Integer> hm = new TreeMap<Character, Integer>();

        //遍历字符串，得到每一个字符
        for (int i = 0; i < line.length(); i++) {
            char key = line.charAt(i);

            //得到的每一个字符作为键到HashMap集合中去找对应的值，看起返回值
            Integer value = hm.get(key);

            if (value == null) {
                //如果返回值是null，说明该字符在HashMap集合中不存在，就把该字符作为键，1作为值存储
                hm.put(key, 1);
            }else {
                //如果返回值是不null，说明该字符在HashMap集合中存在，把该值加1，然后重新储存该字符和对应的值
                value++;
                hm.put(key, value);
            }
            }

        //遍历HashMap集合，得到键和值，按照要求进行拼接
        StringBuilder sb = new StringBuilder();

        Set<Character> keySet = hm.keySet();
        for (Character key : keySet) {
            Integer value = hm.get(key);
            sb.append(key).append("(").append(value).append(")");
        }
        String result = sb.toString();
        System.out.println(result);

    }
}

```



### 6.Collections

### 6.1 Collections概述和使用

概述：针对集合操作的工具类

常用方法：

- public static <T> int binarySearch(List<? extends Comparable<? super T>> list,T key)：将指定的列表按升序排序
- reverse：反转指定列表中元素的顺序
- shuffle：使用默认的随机源随机排列指定的列表

```java
package com.ling.Collections;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Collections01 {
    public static void main(String[] args) {
        ArrayList<Student> array = new ArrayList<Student>();

        Student ling11 = new Student("ling11", 111);
        Student ling22 = new Student("ling22", 22);
        Student ling33 = new Student("ling33", 313);
        Student ling44 = new Student("ling44", 414);

        array.add(ling11);
        array.add(ling22);
        array.add(ling33);
        array.add(ling44);

        Collections.sort(array, new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                int num = s1.getAge() - s2.getAge();
                int num1 = num ==0?s1.getName().compareTo(s2.getName()):num;
                return num1;
            }
        });

        //遍历集合
        for (Student s : array) {
            System.out.println(s.getName()+","+s.getAge());
        }


    }
}

```

### 案例：模拟斗地主



```java
package com.ling.Collections;

import java.util.ArrayList;
import java.util.Collections;

public class Collections02 {
    public static void main(String[] args) {
        //创建一个牌盒，也就是定义一个集合对象，用ArrayList集合实现
        ArrayList<String> array = new ArrayList<String>();

        //往牌盒里面放牌
        /*
        ♦2,3,4...k,A
        ♣
        ♥
        ♠
        大王，小王
         */
        //定义花色数组
        String[] colors = {"♦","♣","♥","♠"};
        //定义点数数组
        String[] numbers = {"2","3","4","5","6","7","8","9","10","J","Q","K","A"};
        for (String color : colors) {
            for (String number : numbers) {
                array.add(color + number);
            }
        }
        array.add("小王");
        array.add("大王");

        //洗牌，就是把牌打散，用Collections的shuffle（）方法实现
        Collections.shuffle(array);

        //发牌，也就是遍历集合，给三个玩家发牌
        ArrayList<String> zyArray = new ArrayList<String>();//赵云
        ArrayList<String> lbArray = new ArrayList<String>();//刘备
        ArrayList<String> gyArray = new ArrayList<String>();//关羽
        ArrayList<String> dpArray = new ArrayList<String>();//底牌

        for (int i = 0; i < array.size(); i++) {
            String poker = array.get(i);
            if (i >= array.size() - 3) {
                dpArray.add(poker);
            } else if (i % 3 == 0) {
                zyArray.add(poker);
            } else if (i % 3 == 1) {
                lbArray.add(poker);
            } else if (i % 3 == 2) {
                gyArray.add(poker);
            }
        }

//        System.out.println(array);

        lookPoker("赵云", zyArray);
        lookPoker("刘备", lbArray);
        lookPoker("关羽",gyArray);
        lookPoker("底牌",dpArray);


    }

    public static void lookPoker(String name,ArrayList<String> array) {
        System.out.print(name+"的牌是：");
        for (String poker : array) {
            System.out.print(poker+" ");
        }
        System.out.println();
    }

}

```

### 案例：模拟斗地主升级版代码实现

```java
package com.ling.Collections;

import java.util.*;

public class Collections03 {
    public static void main(String[] args) {
        //创建HashMap,键是编号，值是牌
        HashMap<Integer, String> hm = new HashMap<Integer, String>();

        //创建ArrayList，存编号
        ArrayList<Integer> array = new ArrayList<>();

        //创建花色数组和点数数组
        String[] colors = {"♦", "♣", "♥", "♠"};
        String[] numbers = {"2","3","4","5","6","7","8","9","10","J","Q","K","A"};

        //从0开始往HashMap里面存储编号，并存储对应的牌，同时往ArrayList里面存储编号
        int index = 0;

        for (String number : numbers) {
            for (String color : colors) {
                hm.put(index, color + number);
                array.add(index);
                index++;
            }
        }
        hm.put(index, "小王");
        array.add(index);
        index++;
        hm.put(index, "大王");
        array.add(index);

//        System.out.println(hm);

        //洗牌（洗的是编号），collections.shufflea()
        Collections.shuffle(array);

        //发牌（发的也是编号），为了保证编号是排序的，创建TreeSet集合
        TreeSet<Integer> zfSet = new TreeSet<Integer>();
        TreeSet<Integer> gySet = new TreeSet<Integer>();
        TreeSet<Integer> lbSet = new TreeSet<Integer>();
        TreeSet<Integer> dpSet = new TreeSet<Integer>();

        for (int i = 0; i < array.size(); i++) {
            int x = array.get(i);//牌的索引
            if (i >= array.size() - 3) {
                dpSet.add(x);
            } else if (i % 3 == 0) {
                zfSet.add(x);
            }else if (i % 3 == 1) {
                lbSet.add(x);
            }else if (i % 3 == 2) {
                gySet.add(x);
            }
        }

        //调用看牌方法
        lookPoker("张飞",zfSet,hm);
        lookPoker("刘备",lbSet,hm);
        lookPoker("关羽",gySet,hm);
        lookPoker("底牌",dpSet,hm);

    }

    //定义方法看牌（遍历TreeSet集合，获取编号，到HashMap集合找相应的牌）,ts编号，hm牌花色点数
    public static void lookPoker(String name,TreeSet<Integer> ts,HashMap<Integer,String> hm) {
        System.out.print(name+"的牌是：");
        for (Integer key : ts) {
            String poker = hm.get(key);
            System.out.print(poker+" ");
        }
        System.out.println();
    }

}

```

